///////////////////////////////////////////////////////////////////////////////
//
//  Copyright 2018-2022 Robonomics Network <research@robonomics.network>
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
///////////////////////////////////////////////////////////////////////////////
//! Robonomics Network discovery service.

use async_std::task;
use clap::Parser;
use futures::prelude::*;
use libp2p::{
    // core::multiaddr::Protocol,
    core::connection::ConnectionId,
    development_transport,
    gossipsub::{
        Gossipsub, GossipsubConfigBuilder, GossipsubEvent, GossipsubMessage, MessageAuthenticity,
        MessageId,
    },
    identity,
    kad::{
        handler::KademliaHandlerProto, record::store::MemoryStore, Kademlia, KademliaEvent, QueryId,
    },
    mdns::{Mdns, MdnsConfig, MdnsEvent},
    swarm::{
        behaviour::toggle::Toggle, handler::multi::IntoMultiHandler, ConnectionHandler,
        IntoConnectionHandler, NetworkBehaviour, NetworkBehaviourAction,
        NetworkBehaviourEventProcess, PollParameters, SwarmEvent,
    },
    // Multiaddr,
    NetworkBehaviour,
    PeerId,
    Swarm,
};
use std::{
    collections::{hash_map::DefaultHasher, HashMap, VecDeque},
    error::Error,
    hash::{Hash, Hasher},
    str::FromStr,
    task::{Context, Poll},
    time::Duration,
};

// Cli args parser.
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    #[clap(long)]
    disable_mdns: bool,

    #[clap(long)]
    disable_kad: bool,

    #[clap(long, default_value_t = 1000)]
    heartbeat_interval: u64,

    #[clap(long, default_value_t = ("").to_string())]
    bootnodes: String,
}

// #[behaviour(out_event = "BehaviourOut<B>", poll_method = "poll", event_process = true)]
// #[behaviour(event_process = true)]
// #[behaviour(out_event = "DiscoveryOut", poll_method = "poll", event_process = true)]

// Event generated by the DiscoveryBehaviour
// #[derive(Debug)]
// enum DiscoveryOut {
//     TestEvent(MdnsEvent),
//     Discovered(PeerId),
// }
//
// impl From<MdnsEvent> for DiscoveryOut {
//     fn from(event: MdnsEvent) -> Self {
//         Self::TestEvent(event)
//     }
// }

// General behaviour of the network. Combines all protocols together.
#[derive(NetworkBehaviour)]
#[behaviour(event_process = true)]
struct RobonomicsNetworkBehaviour {
    pubsub: Gossipsub,
    mdns: Toggle<Mdns>,
    kademlia: Toggle<Kademlia<MemoryStore>>,
    // Number of nodes we're currently connected to.
    // num_connections: u64,
    // Events to return in priority when polled.
    // pending_events: VecDeque<DiscoveryOut>,
    // Kademlia requests and answers.
    // kademlias: HashMap<u64, Kademlia<MemoryStore>>,
}

// impl NetworkBehaviour for RobonomicsNetworkBehaviour {
//     type ConnectionHandler = IntoMultiHandler<u64, KademliaHandlerProto<QueryId>>;
//     type OutEvent = DiscoveryOut;
//
//     fn new_handler(&mut self) -> Self::ConnectionHandler {
//         let iter = self
//             .kademlias
//             .iter_mut()
//             .map(|(p, k)| (p.clone(), NetworkBehaviour::new_handler(k)));
//
//         IntoMultiHandler::try_from_iter(iter).expect("")
//     }
//
//     fn inject_event(
//         &mut self,
//         peer_id: PeerId,
//         connection: ConnectionId,
//         (pid, event): <<Self::ConnectionHandler as IntoConnectionHandler>::Handler as ConnectionHandler>::OutEvent,
//     ) {
//         if let Some(kad) = self.kademlias.get_mut(&pid) {
//             return kad.inject_event(peer_id, connection, event);
//         }
//         log::error!(
//             target: "sub-libp2p",
//             "inject_node_event: no kademlia instance registered for protocol {:?}",
//             pid,
//         )
//     }
//
//     fn poll(
//         &mut self,
//         cx: &mut Context,
//         params: &mut impl PollParameters,
//     ) -> Poll<NetworkBehaviourAction<Self::OutEvent, Self::ConnectionHandler>> {
//         // Immediately process the content of `discovered`.
//         if let Some(ev) = self.pending_events.pop_front() {
//             return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
//         }
//
//         // Poll the stream that fires when we need to start a random Kademlia query.
//         // if let Some(next_kad_random_query) = self.next_kad_random_query.as_mut() {
//         //     while next_kad_random_query.poll_unpin(cx).is_ready() {
//         //         let actually_started = if self.num_connections < self.discovery_only_if_under_num {
//         //             let random_peer_id = PeerId::random();
//         //             debug!(
//         //                 target: "sub-libp2p",
//         //                 "Libp2p <= Starting random Kademlia request for {:?}",
//         //                 random_peer_id,
//         //             );
//         //             for k in self.kademlias.values_mut() {
//         //                 k.get_closest_peers(random_peer_id);
//         //             }
//         //             true
//         //         } else {
//         //             debug!(
//         //                 target: "sub-libp2p",
//         //                 "Kademlia paused due to high number of connections ({})",
//         //                 self.num_connections
//         //             );
//         //             false
//         //         };
//         //
//         //         // Schedule the next random query with exponentially increasing delay,
//         //         // capped at 60 seconds.
//         //         *next_kad_random_query = Delay::new(self.duration_to_next_kad);
//         //         self.duration_to_next_kad =
//         //             cmp::min(self.duration_to_next_kad * 2, Duration::from_secs(60));
//         //
//         //         if actually_started {
//         //             let ev = DiscoveryOut::RandomKademliaStarted(
//         //                 self.kademlias.keys().cloned().collect(),
//         //             );
//         //             return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
//         //         }
//         //     }
//         // }
//
//         // Poll Kademlias.
//         // for (pid, kademlia) in &mut self.kademlias {
//         //     while let Poll::Ready(ev) = kademlia.poll(cx, params) {
//         //         match ev {
//         //             NetworkBehaviourAction::GenerateEvent(ev) => match ev {
//         //                 KademliaEvent::RoutingUpdated { peer, .. } => {
//         //                     let ev = DiscoveryOut::Discovered(peer);
//         //                     return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
//         //                 }
//         //                 KademliaEvent::UnroutablePeer { peer, .. } => {
//         //                     let ev = DiscoveryOut::UnroutablePeer(peer);
//         //                     return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
//         //                 }
//         //                 KademliaEvent::RoutablePeer { peer, .. } => {
//         //                     let ev = DiscoveryOut::Discovered(peer);
//         //                     return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
//         //                 }
//         //                 KademliaEvent::PendingRoutablePeer { .. }
//         //                 | KademliaEvent::InboundRequest { .. } => {
//         //                     // We are not interested in this event at the moment.
//         //                 }
//         //                 KademliaEvent::OutboundQueryCompleted {
//         //                     result: QueryResult::GetClosestPeers(res),
//         //                     ..
//         //                 } => match res {
//         //                     Err(GetClosestPeersError::Timeout { key, peers }) => {
//         //                         debug!(
//         //                             target: "sub-libp2p",
//         //                             "Libp2p => Query for {:?} timed out with {} results",
//         //                             HexDisplay::from(&key), peers.len(),
//         //                         );
//         //                     }
//         //                     Ok(ok) => {
//         //                         trace!(
//         //                             target: "sub-libp2p",
//         //                             "Libp2p => Query for {:?} yielded {:?} results",
//         //                             HexDisplay::from(&ok.key), ok.peers.len(),
//         //                         );
//         //                         if ok.peers.is_empty() && self.num_connections != 0 {
//         //                             debug!(
//         //                                 target: "sub-libp2p",
//         //                                 "Libp2p => Random Kademlia query has yielded empty results",
//         //                             );
//         //                         }
//         //                     }
//         //                 },
//         //                 KademliaEvent::OutboundQueryCompleted {
//         //                     result: QueryResult::GetRecord(res),
//         //                     stats,
//         //                     ..
//         //                 } => {
//         //                     let ev = match res {
//         //                         Ok(ok) => {
//         //                             let results = ok
//         //                                 .records
//         //                                 .into_iter()
//         //                                 .map(|r| (r.record.key, r.record.value))
//         //                                 .collect();
//         //
//         //                             DiscoveryOut::ValueFound(
//         //                                 results,
//         //                                 stats.duration().unwrap_or_default(),
//         //                             )
//         //                         }
//         //                         Err(e @ libp2p::kad::GetRecordError::NotFound { .. }) => {
//         //                             trace!(
//         //                                 target: "sub-libp2p",
//         //                                 "Libp2p => Failed to get record: {:?}",
//         //                                 e,
//         //                             );
//         //                             DiscoveryOut::ValueNotFound(
//         //                                 e.into_key(),
//         //                                 stats.duration().unwrap_or_default(),
//         //                             )
//         //                         }
//         //                         Err(e) => {
//         //                             debug!(
//         //                                 target: "sub-libp2p",
//         //                                 "Libp2p => Failed to get record: {:?}",
//         //                                 e,
//         //                             );
//         //                             DiscoveryOut::ValueNotFound(
//         //                                 e.into_key(),
//         //                                 stats.duration().unwrap_or_default(),
//         //                             )
//         //                         }
//         //                     };
//         //                     return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
//         //                 }
//         //                 KademliaEvent::OutboundQueryCompleted {
//         //                     result: QueryResult::PutRecord(res),
//         //                     stats,
//         //                     ..
//         //                 } => {
//         //                     let ev = match res {
//         //                         Ok(ok) => DiscoveryOut::ValuePut(
//         //                             ok.key,
//         //                             stats.duration().unwrap_or_default(),
//         //                         ),
//         //                         Err(e) => {
//         //                             debug!(
//         //                                 target: "sub-libp2p",
//         //                                 "Libp2p => Failed to put record: {:?}",
//         //                                 e,
//         //                             );
//         //                             DiscoveryOut::ValuePutFailed(
//         //                                 e.into_key(),
//         //                                 stats.duration().unwrap_or_default(),
//         //                             )
//         //                         }
//         //                     };
//         //                     return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
//         //                 }
//         //                 KademliaEvent::OutboundQueryCompleted {
//         //                     result: QueryResult::RepublishRecord(res),
//         //                     ..
//         //                 } => match res {
//         //                     Ok(ok) => debug!(
//         //                         target: "sub-libp2p",
//         //                         "Libp2p => Record republished: {:?}",
//         //                         ok.key,
//         //                     ),
//         //                     Err(e) => debug!(
//         //                         target: "sub-libp2p",
//         //                         "Libp2p => Republishing of record {:?} failed with: {:?}",
//         //                         e.key(), e,
//         //                     ),
//         //                 },
//         //                 // We never start any other type of query.
//         //                 KademliaEvent::OutboundQueryCompleted { result: e, .. } => {
//         //                     warn!(target: "sub-libp2p", "Libp2p => Unhandled Kademlia event: {:?}", e)
//         //                 }
//         //             },
//         //             NetworkBehaviourAction::Dial { opts, handler } => {
//         //                 let pid = pid.clone();
//         //                 let handler = self.new_handler_with_replacement(pid, handler);
//         //                 return Poll::Ready(NetworkBehaviourAction::Dial { opts, handler });
//         //             }
//         //             NetworkBehaviourAction::NotifyHandler {
//         //                 peer_id,
//         //                 handler,
//         //                 event,
//         //             } => {
//         //                 return Poll::Ready(NetworkBehaviourAction::NotifyHandler {
//         //                     peer_id,
//         //                     handler,
//         //                     event: (pid.clone(), event),
//         //                 })
//         //             }
//         //             NetworkBehaviourAction::ReportObservedAddr { address, score } => {
//         //                 return Poll::Ready(NetworkBehaviourAction::ReportObservedAddr {
//         //                     address,
//         //                     score,
//         //                 })
//         //             }
//         //             NetworkBehaviourAction::CloseConnection {
//         //                 peer_id,
//         //                 connection,
//         //             } => {
//         //                 return Poll::Ready(NetworkBehaviourAction::CloseConnection {
//         //                     peer_id,
//         //                     connection,
//         //                 })
//         //             }
//         //         }
//         //     }
//         // }
//
//         // Poll mDNS.
//         while let Poll::Ready(ev) = self.mdns.poll(cx, params) {
//             match ev {
//                 NetworkBehaviourAction::GenerateEvent(event) => match event {
//                     MdnsEvent::Discovered(list) => {
//                         // if self.num_connections >= self.discovery_only_if_under_num {
//                         //     continue;
//                         // }
//
//                         self.pending_events
//                             .extend(list.map(|(peer_id, _)| DiscoveryOut::Discovered(peer_id)));
//                         if let Some(ev) = self.pending_events.pop_front() {
//                             return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
//                         }
//                     }
//                     MdnsEvent::Expired(_) => {}
//                 },
//                 NetworkBehaviourAction::Dial { .. } => {
//                     unreachable!("mDNS never dials!");
//                 }
//                 NetworkBehaviourAction::NotifyHandler { event, .. } => match event {}, #<{(| `event` is an enum with no variant |)}>#
//                 NetworkBehaviourAction::ReportObservedAddr { address, score } => {
//                     return Poll::Ready(NetworkBehaviourAction::ReportObservedAddr {
//                         address,
//                         score,
//                     })
//                 }
//                 NetworkBehaviourAction::CloseConnection {
//                     peer_id,
//                     connection,
//                 } => {
//                     return Poll::Ready(NetworkBehaviourAction::CloseConnection {
//                         peer_id,
//                         connection,
//                     })
//                 }
//             }
//         }
//
//         Poll::Pending
//     }
// }

impl NetworkBehaviourEventProcess<MdnsEvent> for RobonomicsNetworkBehaviour {
    // Called when `mdns` produces an event.
    fn inject_event(&mut self, event: MdnsEvent) {
        match event {
            // Discovered nodes through mDNS.
            MdnsEvent::Discovered(list) => {
                for (peer_id, multiaddr) in list {
                    // Remove Ws component from multiaddr.
                    // let mut no_ws_multiaddr = Multiaddr::empty();
                    // for comp in multiaddr.iter() {
                    //     match comp {
                    //         Protocol::Ws(_) => continue,
                    //         _ => no_ws_multiaddr.push(comp),
                    //     };
                    // }

                    // Add multiaddr to kad.
                    // if let Some(kad) = self.kademlia.as_mut() {
                    //     // kad.add_address(&peer_id, no_ws_multiaddr);
                    //     kad.add_address(&peer_id, multiaddr);
                    // };
                    log::info!("mDns discovered: {:?}", peer_id);
                }
            }
            // The given combinations of PeerId and Multiaddr have expired.
            MdnsEvent::Expired(list) => {
                for (peer_id, multiaddr) in list {
                    // if let Some(kad) = self.kademlia.as_mut() {
                    //     kad.remove_address(&peer_id, &multiaddr);
                    // };
                    log::info!("mDns expired: {:?}", peer_id);
                }
            }
        }
    }
}

impl NetworkBehaviourEventProcess<KademliaEvent> for RobonomicsNetworkBehaviour {
    // Called when `kademlia` produces an event.
    fn inject_event(&mut self, event: KademliaEvent) {
        match event {
            // The routing table has been updated with a new peer/address
            KademliaEvent::RoutingUpdated { peer, .. } => {
                log::info!("Kad new peer: {:?}", peer);

                // self.pubsub.add_explicit_peer(&peer);
            }
            // KademliaEvent::InboundRequest { request } => {
            //     log::info!("InboundRequest!");
            // }
            // KademliaEvent::PendingRoutablePeer { peer, address } => {
            //     log::info!("PendingRoutablePeer!");
            // }
            // KademliaEvent::RoutablePeer { peer, address } => {
            //     log::info!("RoutablePeer!");
            // }
            // KademliaEvent::UnroutablePeer { peer } => {
            //     log::info!("UnroutablePeer!");
            // }
            // KademliaEvent::OutboundQueryCompleted { result, .. } => {
            //     log::info!("OutboundQueryCompleted!");
            // }
            // _ => {}
            event => {
                println!("kad >>>>>>>>> {:?}", event);
            }
        }
    }
}

impl NetworkBehaviourEventProcess<GossipsubEvent> for RobonomicsNetworkBehaviour {
    // Called when `gossipsub` produces an event.
    fn inject_event(&mut self, event: GossipsubEvent) {
        log::info!("Gossipsub event: {:?}", event);
        // if let GossipsubEvent::Message { message, .. } = event {
        //     log::info!("message: {:?}", message);
        // }
    }
}

#[async_std::main]
async fn main() -> Result<(), Box<dyn Error>> {
    env_logger::init();
    let args = Args::parse();

    // Create a random PeerId.
    let local_key = identity::Keypair::generate_ed25519();
    let local_peer_id = PeerId::from(local_key.public());
    log::info!("Local peer ID: {:?}", local_peer_id);

    // Set up a an encrypted DNS-enabled TCP Transport.
    let transport = development_transport(local_key.clone()).await?;

    let gossipsub_config = GossipsubConfigBuilder::default()
        .heartbeat_interval(Duration::from_millis(args.heartbeat_interval))
        .message_id_fn(|message: &GossipsubMessage| {
            // To content-address message,
            // we can take the hash of message and use it as an ID.
            let mut s = DefaultHasher::new();
            message.data.hash(&mut s);
            MessageId::from(s.finish().to_string())
        })
        .build()
        .expect("Valid gossipsub config");

    // Create PubSub
    let pubsub = Gossipsub::new(MessageAuthenticity::Signed(local_key), gossipsub_config)
        .expect("Correct configuration");

    // Use mDNS.
    let mdns = if !args.disable_mdns {
        log::info!("Using mDNS discovery service.");
        let mdns = task::block_on(Mdns::new(MdnsConfig::default()))?;
        Toggle::from(Some(mdns))
    } else {
        Toggle::from(None)
    };

    // Parse bootnodes.
    let bootnodes: Vec<&str> = args.bootnodes.split(",").map(|s| s.trim()).collect();
    let mut boot_peers: Vec<PeerId> = vec![];
    for node in bootnodes {
        if let Ok(peer) = PeerId::from_str(node) {
            boot_peers.push(peer)
        }
    }

    // Use DHT.
    let kademlia = if !args.disable_kad {
        log::info!("Using DHT discovery service.");
        let store = MemoryStore::new(local_peer_id);
        let mut kademlia = Kademlia::new(local_peer_id, store);
        let bootaddr = libp2p::Multiaddr::from_str("/dnsaddr/bootstrap.libp2p.io")?;
        // Adding robonomics bootnodes.
        for peer in &boot_peers {
            log::info!("Adding bootnode: {:?}", peer);
            kademlia.add_address(&peer, bootaddr.clone());
        }
        Toggle::from(Some(kademlia))
    } else {
        Toggle::from(None)
    };

    // let num_connections = 0;
    // let pending_events = VecDeque::new();
    // let kademlias = HashMap::new();

    // Custom NetworkBehaviour.
    let behaviour = RobonomicsNetworkBehaviour {
        // TODO: add reqresp
        kademlia,
        mdns,
        pubsub,
        // num_connections,
        // pending_events,
        // kademlias,
    };

    // Create a swarm to manage peers and events.
    let mut swarm = Swarm::new(transport, behaviour, local_peer_id);

    // Listen on all interfaces and whatever port the OS assigns.
    swarm.listen_on("/ip4/0.0.0.0/tcp/0".parse()?)?;

    loop {
        match swarm.select_next_some().await {
            // // ???
            // SwarmEvent::ConnectionEstablished { peer_id, .. } => {
            //     println!("Connected to: {:?}", peer_id);
            // }
            // // ???
            // SwarmEvent::Behaviour(event) => {
            //     println!("Event: {:?}", event);
            // }
            // SwarmEvent::NewListenAddr { address, .. } => {
            //     println!("Listening on {:?}", address);
            // }
            event => {
                println!(">>>> {:?}", event);
            } // _ => {}
        }
    }
}
